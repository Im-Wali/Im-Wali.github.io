---
title:  "관계형 데이터 모델링 노트 : 05 관계 이야기"
search: false
categories:
  - DataModeling
tags:
  - Data
  - Data Modeling
  - Modeling
  - 관계형 데이터 모델링 노트
  - 데이터 모델링
  - 관계
  - 모델링
  - Relationship
---
<br/>
# Chapter 5 : 관계 이야기

## 서론
  * **"관계형 데이터 모델링 노트"** 책을 통해 진행한 이론 스터디 다섯번째 시간이다.
  <br/>
  모델링에서 관계란 엔티티 간의 논리적인 연관성을 이야기한다. 이 책에서는 관계 또한 하나의 속성으로 보고 설명한다. 이번 시간에는 모델링 시 관계에 대해서 고려해야될 사항들과 발생하는 현상들에 대해서 포스팅 해보겠다.
  <br/>

## 관계에 대한 서설
  * 관계와 연관해서 기억할 두 단어는 관계 속성과 참조 무결성이다.
  <br/>
  * 관계는 물리적으로 관계 속성과 참조 무결성 제약, 이 두가지를 생성한다.
  <br/>
  * 관계와 혼동하는 것이 업무 흐름이다. 업무 흐름을 무조건 관계로 표현하려는 경향이 있지만, 업무 흐름과 관계는 같지 않다. 관계로 표현되는 업무 흐름이 일 부 있을 뿐이다.
  <br/>

## 관계선이 의미하는 것
 * **업무 규칙**
 * **업무 프로세스**
 * **조인**
 * **입력 순서**

## 관계를 설계할 때 고려 사항
  * 속성으로 관리하려는 관계
  * 참조 무결성 관계
  * 바로 상위의 1차 관계

## 참조 무결성
  * 하위(자식) 엔티티의 외래 식별자 속성(관계 속성)에 존재하는 값이 상위(부모) 엔티티의 주 식별자 값과 일치하거나 널이면 참조 무결성을 만족한다고 한다. 두 엔티티가 이와 같은 상태에 있으면 참조 무결성 관계라고 한다.
  <br/>

  * 참조 무결성은 논리적인 개념이다. 이를 모델에 표현하는 것이 관계선이며, DBMS에서 물리적으로 구현한 것이 참조 무결성 제약이다.
  <br/>

  * 물리적인 FK 제약을 생성하지 않는 것과 참조 무결성 관계가 없는 것은 본질적으로 다른 얘기다. 데이터 관점에서 참조 무결성이  존재하면 FK 제약이 없더라도 참조 무결성 관계다.
  <br/>

  * 참조 무결성은 논리적인 개념이고 그에 대한 물리적인 개념을 참조 무결성 제약이지만, 일반적으로 참조 무결성 참조 무결성 제약을 동일한 의미로 사용된다.
  <br/>

  * 실무에서 실제로 참조 무결성 제약을 생성하는 경우는 드물다. 첫번째 이유는 성능이 떨어진다. 두번째로는 개발하기 불편하다는 이유 때문이다.
  <br/>

## 기준 엔티티의 참조 무결성
  * 기준 엔티티에는 업무에서 참조하는 일자나 금액, 율 등의 데이터를 관리하는 엔티티가 포함된다. 대부분의 기준 데이터는 조회해서 참조하는 것이므로 참조 무결성 관계가 존재하지 안흔 것이 일반적이지만, 이 판단은 업무 요건에 따라 달라진다.
  <br/>

## 종속 관계와 참조 관계
  * 관계는 두 개 이상의 엔티티 간에 존재하는 연관성이다. 엔티티 간의 연관성은 두 가지 종류가 있다. 하나는 종속 관계이고 다른 하나는 참조 관계이다.
  <br/>

  * 종속 관계는 부모 엔티티와 자식 엔티티 간의 관계로 이 관계에서는 부모 엔티티가 없으면 자식 엔티티가 존재할 수 없다.
  <br/>

  * 참조 관계는 단지 어떤 엔티티와의 연관성을 관리하려는 관계일 뿐 상위 엔티티가 없다고 존재할 수 없다.
  <br/>

  * 참조 관계는 단지 어떤 엔티티와의 연관성을 관리ㅏ하려는 관계일 분 상위 엔티티가 없다고 존재할 수 없는 관계가 아니다.
  <br/>

  * 종속 관계에는 두가지 종류가 있는데, 데이터 본질적으로 종속 관계인 것이 있고 업무적으로 종속 관계인 것이 있다.
  <br/>

  <br/>
  ![image-center](/assets/images/2021-05-01_Dependency_relation_01.jpg){: .align-center}
  <br/>
  ![image-center](/assets/images/2021-05-01_Dependency_relation_02.jpg){: .align-center}

## 식별 관계와 비식별 관계
  * 주식별자를 하위 엔티티에 어떻게 상속핳느냐에 따라 식별관계와 비식별관계로 나눌 수 있다. 이를 관계 타입이라고 한다.
  <br/>

  * 종속, 참조 관계는 식별, 비식별 관계를 선택하는 기준이 된다.
  <br/>

  * 상위 엔티티의 주 식별자를 하위 엔티티로 상속할 때, 주 식별자에 포함시키는 것을 식별 관계라고 한다.
  <br/>

  * 비식별 관계는 상위 엔티티의 주 식별자가 하위 엔티틸 상속될 때 일반 속성에 포함되는 관계다.
  <br/>

  * 식별 관계는 또한 주 식별자를 인덱스로 사용할 수 있다. 상위/하위 엔티티를 동시에 조회하는 경우가 많을 경우 매우 효율적이다.
  <br/>

## 종속/참조 관계와 식별/비식별 관계
  * 상위 엔티티의 주 식별자를 하위 엔티티에 식별자로서 상속할지 속성으로 상속할지를 결정하는 것은 어렵다. 이 결정에는 일반적으로 원칙이 존재한다. 두 엔티티의 관계가 종속 관계일 때는 식별자로서 상속하는 것이다. 반면에 하위 엔티티가 상위 엔티티에 존재 종속되지 않으면, 즉 상위 엔티티가 존재하지 않아도 하위 에티티가 존재할 수 있으면 일반 속성으로 상속하는 게 원칙이다.
  <br/>

  * **종속 관계이면서 식별관계**
    - 종속 관계이기 떄문에 자연스럽게 주 식별자를 식별 관계로 상속한 정상적인 모델이다. 하지만 이 모델에는 몇가지 단점이 존재한다. 첫번째는 변화에 취약하다. 두번째는 하위 엔티티의 주 식별자가 복잡해진다.
    <br/>

    <br/>
    ![image-center](/assets/images/2021-05-01_Existence_Dependency_01.jpg){: .align-center}

  * **종속 관계이면서 비식별 관계**
    - 속성 엔티티의 엔티티 번호 속성을 일반 속성으로 내리고, 인조 식별자를 사용한다. 이렇게 사용하는 경우 훨씬 유연하게 사용할 수 있다. 이는 엔티티 관계를 전략적으로 약 결합 상태로 만든 모델이다.
    <br/>

    <br/>
    ![image-center](/assets/images/2021-05-01_Existence_Dependency_02.jpg){: .align-center}

    * **참조 관계 이면서 비식별 관계**
      - 이런 참조 관계에서는 하위 엔티티의 주 식별자는 인조 식별자이거나 자신의 업무 식별자이다.
      ![image-center](/assets/images/2021-05-01_Nonexistence_Dependency_01.jpg){: .align-center}

    * **참조 관계이면서 식별관계**
      - 참조 관계이면서 식별 관계는 매우 드물다. 일반적으로 잘못 설계한 모델이다.
      ![image-center](/assets/images/2021-05-01_Nonexistence_Dependency_02.jpg){: .align-center}

## 식별 관계와 비식별관계를 채택하는 예외 경우
  * 종속 관게이면 식별관계를 사용하고 참조 관계라면 비식별관계를 사용하는 것이 기본이지만 예외인 사항들이 있다. 다만 참조 관계일 때 식별관계를 사용하는 경우는 잘못 사용하는 경우 모델이 크게 흔들릴 수 있어 주의 해야 한다.
  <br/>

  * **성능 고려**
    - B는 A에 종속, D는 C의 종속되어 있는 관게이면서 D에서 A를 참조하는 경우가 많다면, C에 B의 주식별자를 상속하면 D엔티티에서 A엔티티를 바로 조인할 수 있어 엑세스 단계를 줄일 수 있다.
    <br/>

    ![image-center](/assets/images/2021-05-01_relationship_01.jpg){: .align-center}

  * **모델 구조 구려**
    - 모델을 단순하게 만들 때 주식별자를 속성으로 상속하는 전략도 필요하다. 주 식별자가 여러 속성으로 구성되면 다른 엔티티와 관계가 복잡해지므로 하위 엔티티가 많이 존재하는 중요한 엔티티는 효율적이지 않다.
    <br/>
    <br/>
    ![image-center](/assets/images/2021-05-01_relationship_02.jpg){: .align-center}
    <br/>
    ![image-center](/assets/images/2021-05-01_relationship_03.jpg){: .align-center}

## 관계 속성과 관계 엔티티
  * 선으로 표현된 관계선의 실상은 참조 무결성 제약과 관계 속성이다.
  <br/>

  * 두 엔티티 간의 연관 관계가 한정적일 때는 고나계 속성으로 관리할 수 있지만, 연관 관계가 많아지거나 많아질 가능성이 있다면 관계 속성으로 관리할 수 없고 엔티티로 관리해야 한다.
  <br/>

## 관계 엔티티의 특징
  * **유연성**
  * **부가 속성 관리 용이**
  * **하위 엔티티 관리 용이**
  * **중복 석송 관리**
  * **자체 이력 관리**

## 관계 엔티티 선택 기준
  * 관계가 늘어날 가능성이 있는 경우
  * 조회 요건
  * 이력 관리 여부

  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_04.jpg){: .align-center}

## 관계선의 구성 요소
    <br/>
  ![image-center](/assets/images/2021-05-01_relationship_05.jpg){: .align-center}

  * **관계비(Cardinality)**
  * **관계명(Relationship name)**
  * **관계 타입(Relationship Type)**
  * **관계 차수(Relationship Degree)**
  * **관계 존재성(Optionality)**

## 관계 구성 요소 - 관계비
  * 관계비는 상위 엔티티의 한개의 인스턴스가 하위 엔티티의 몇 개의 인스턴스와 연관되어 있는지를 의미하는 용어다. 이는 일종의 제약으로 Participation 이라고도 표현한다.
  <br/>

  * **관계비 종류**
    - 일대일 관계
    - 일대다 관계
    - 다대다 관계

  * **관계비 분석 방법**
    - 관계비 분석의 핵심은 상대 인스턴스 개수가 하나인지, 하나 이상인지를 파악하는 것이다.
    - 일반적으로 관계비는 관계 존재성을 포함하고 있다.
    - 관계비 분석할 때 주의할 점은 두가지이다. 우선 관계비는 특정 시점을 기준으로 하지 않는다. 그리고 또 다른 한가지는 이력 데이터다. 이력 데이터를 포함할 경우 관계비는 단계가 하나씩 올라간다.

## 관계 구성 요소 - 관계 존재성
  * 관계 존재성은 하나의 인스턴스와 관계 있는 상대 인스턴스의 존재 여부를 의미한다. 즉 하위 엔티티의 인스턴스와 연관되는 상위 엔티티의 인스턴스가 반드시 존재해야 하는지 존재하지 않아도 되는지를 의미한다.
  <br/>

  * 상위 엔티티의 관계 존재성이 선택일 때 특히 주의해야 한다. 상위 엔티티 쪽은 관계 존재성이 선택인 관계가 많을수록 모델의 모호성도 증가한다. 가능하면 상위 엔티티 쪽이 필수가 되도록 설계해야 한다.
  <br/>

  * **관계비와 관계 존재성의 표기법**
    ![image-center](/assets/images/2021-05-01_relationship_06.jpg){: .align-center}

  * **관계 존재성과 관계 속성의 널 제약**
    - 관계 존재성과 관계 속성의 널 제약을 같은 것으로 혼동하는 경우가 많다. 일부 CASE 툴의 기능을 이 둘을 연결하여 더욱 혼란스럽다.
    <br/>

## 관계 구성 요소 - 관계 참여수
  * 관계 참여수(Relationship Degree)는 관계와 연관된 엔티티의 개수를 의미한다. 하나의 관게에 포함된 엔티티의 개수를 관계 참여수라고 한다.
  <br/>

  * 관계 참여수는 세가지로 구분할 수 있다. 가장 흔한 참여수는 2이며, 이는 두 개의 엔티티 간의 관계를 의미한다. 종좆 1인 관계도 존재한다. 하나의 엔티티에서 발생하는 관계를 재귀관계 또는 1개체 관계라고 한다. 그리고 간혹 세 개의 엔티티에서 발생하는 관계가 있다. 이를 3개체 관계 혹은 N개체 관계라고 한다.
  <br/>

  * 다대다 관계와 마찬가지로 3개체 관계도 관계를 표현할려면 새로운 엔티티가 필요하다.
  <br/>

  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_07.jpg){: .align-center}

  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_08.jpg){: .align-center}

  * **관계 참여수와 주 식별자**
    - 3개체 관계의 경우 일종의 교차 엔티티이기 때문에 관계가 주 식별자와 직접 연관된다. 3개체 이상이 관여한 관게는 주 식별자를 도출하기가 쉽지 않다.
    <br/>

    - 3개체 관계 엔티티의 주 식별자는 반드시 세 개의 속성으로 구성되는 것은 아니다. 이는 교차 엔티티도 마찬가지다. 인스턴스를 유일하게 식별할 수 있도록 주 식별자를 도출해야 한다.
    <br/>

    <br/>
    ![image-center](/assets/images/2021-05-01_relationship_12.jpg){: .al2021-05-01_relationship_12.jpggn-center}

## 관계 구성 요소 - 관계 명
  * 관계 명은 관계선 위에 표시하는 관계의 이름이다. 관계명은 모델의 가독성을 높이기 위해서 사용된다.
  <br/>

  * 양쪽 엔티티 명과 관계 속성 명을 제대로 명명했다면 대부분 관계 명은 없어도 된다.
  <br/>

  * 관계 명을 붙이는 원칙은 명사형으로 관계선의 중상ㅇ에 붙이는 것이다. 모든 관계선에 관계 명을 표현해야 한다는 원칙은 잘못된 원칙이다. 더구나 관계선 양쪽에 관계 동사로서 표현해야 한다는 원칙은 바람직하지 않다.
  <br/>

  * **관계 명 붙이는 방법**
    - 기본적으로 양쪽의 엔티티 명이 제대로 정해져 있어야 한다.
    - 상, 하위 관계가 있다면 하위 + 상위 엔티티 형식으로 만든다.
    - 수식어가 필요한 경우 : 하위 + 수식어 + 상위 엔티티
    <br/>

  * **관계명이 필요할 때**
    - 수식어가 필요할때
    - 재귀 관계 일 때
    - 추출 관계 일 때
    - 양방향 관계 일 때
    - 다대다 관계 일 때
    <br/>

  * **필요 없는 경우**
    - 하위 엔티티가 상위 엔티티에 종속되는 경우
    - 일대일 관계를 가지는 경우
    - 내역 형태의 관계를 가지는 경우
    <br/>

## 일대일 관계
  * 일대인 관계는 비교적 자주 등장하는 관계이면서 설계할 때 혼란스러울 수 있는 관계이다. 일대인 관계가 발생하는 이유는 크게 두가지로 구분할 수 있다. 하나는 업무 규칙에 의해서 발생하는 자연스러운 일대일 관계이고 다른 하나는 성능 이나 관리 측면에서 발생하는 인위적인 일대인 관계다.
  <br/>

  * 성능을 고려해서 엔티티를 수직 분해하는 것은 데이터 무결성을 저해하는 비정규화가 아니다. 가능하면 성능을 우선적으로 고려해서 설계하는 것이 바람직하다.
  <br/>

## 일대일 관계와 이력 데이터
  * 일대일 관계에는 이력 데이터가 포함되지 않는다.
  <br/>

  * 업무 규칙에 따라서 발생하는 일대일 관계는 현재 유효한 데이터 간의 관계를 의미한다. 이력 데이터까지 고려하면 일대일 관계는 있을 수 없다.
  <br/>

  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_09.jpg){: .align-center}

  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_10.jpg){: .align-center}

## 베타 관계
  * 베타 관계는 실무에서 꽤 자주 볼 수 있다. 베타 관계는 두개 이상의 상위 엔티티와 관계를 가지며, 그 관계가 상호 베타적일 때의 관계를 말한다. 하위 에니팉의 하나의 인스턴스는 관계를 가지는 두 개 이상의 상위 엔티티 중에서 하나의 엔티티와 관계를 가진다.
  <br/>

  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_11.jpg){: .align-center}


## 재귀 관계
  * 엔티티의 특정 인스턴스가 같은 엔티티의 다른 인스턴스와 관계를 가지는 관계를 재귀 관게라고 한다. 리커시브 관계, 자기 참조 관계라고도 한다.
  <br/>

  * 재귀 관계가 발생하는 대표적인 때는 계층 데이터를 관리할 때와 자기 참조 데이터를 관리할 때이다.
  <br/>

  * **계층**
    - 계층 데이터에는 소속 개념이 존재한다. 큰 조직이나 분류 아래 작은 것이 소속된 형태가 계층 데이터를 이룬다.
    <br/>
    ![image-center](/assets/images/2021-05-01_relationship_13.jpg){: .align-center}


  * **자기참조**
    - 엔티티 한 인스턴스가 자신의 엔티티에 존재하는 다른 인스턴스를 참조할 때 자기 참조라고 한다.
    <br/>
  ![image-center](/assets/images/2021-05-01_relationship_14.jpg){: .align-center}

## 재귀 관계의 관계비
  * 재귀 관계도 일반 관계와 마찬가지로 일대일 관계, 다대다 관계가 존재한다. 다대다 재귀 관계를 해소하면 교차 엔티티가 생기는데, 이를 특별히 BOM 모델이라고 한다.
  <br/>

  * **일대일 재귀 관계**
    - 실무에서는 자주 발생하지 않는다.
    <br/>
  ![image-center](/assets/images/2021-05-01_relationship_15.jpg){: .align-center}


  * **일대다 재귀 관계**
    - 일반 관계와 마찬가지로 일대다 재귀 관계가 가장 일반적이다.
    <br/>
  ![image-center](/assets/images/2021-05-01_relationship_16.jpg){: .align-center}


  * **다대다 재귀 관계**
    - 재귀 관계 중에서 다대다 관계가 발생하는 모델을 BOM 모델이라고 한다. 시룸에서 BOM 관계는 그다지 많이 발생하지 않는다.
    <br/>
  ![image-center](/assets/images/2021-05-01_relationship_17.jpg){: .align-center}

    <br/>
  ![image-center](/assets/images/2021-05-01_relationship_18.jpg){: .align-center}


## 추출 관계
  * 추출 관계는 중복 관계라고도 한다. 추출 속성이 관계일 경우 추출 관계가 된다. 추출 관계는 이미 존재하는 관계로 구현이 가능한 관계다. 다시 생성할 수 있으므로 따로 관리하지 않아도 되는 없어도 되는 관계이다
  <br/>

  * 추출 관계를 사용하는 경우는 두가지다. 상속되는 관계의 깊이를 줄이려고 사용하거나 추출 속성을 채택하기기 위해 사용한다. 이렇게 추출 관계를 사용하는 목적은 성능 향상을 위해서다.
  <br/>

  * **추출 속성이 사용되는 경우**
    - 상속되는 관계의 깊이를 줄이려는 경우
    <br/>
    ![image-center](/assets/images/2021-05-01_relationship_19.jpg){: .align-center}
    - 추출 속성을 채택하기 위해서 사용
    <br/>
    ![image-center](/assets/images/2021-05-01_relationship_20.jpg){: .align-center}

## 양방향 관계
  * 두 엔티티 간에 서로 존재하는 관계가 양방향 관계다. 상호 관계나 교차 관계라고도 한다.
  <br/>

  * 실무에서 양방향 관계는 크게 두 가지 이유에서 나타난다. 업무에 필요한 요견을 반영해서 나타날 수 있으며, 추출 관계를 사용해서 나타날 수 있다.
  <br/>

  * 관계를 잘못 도출했을 때를 제외하면 양방향 관계나 순환 관계는 잘못된 관계가 아니다. 단순히 관계선의 모양만 보고 판단해서는 안되며 관리하려는 속성, 즉 요건으로 판단해야 한다.
  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_21.jpg){: .align-center}
  <br/>
  ![image-center](/assets/images/2021-05-01_relationship_22.jpg){: .align-center}

## 잘못 설계한 관계선
  * 관계선을 잘못 표현하는 유형은 크게 두 가지가 있다. 하나는 엔티티 간에 연관성이 존재하는데 관계를 표현하지 않은 것이고, 다른 하나는 연관성이 없느데도 관계를 표현하는 것이다.
  <br/>

  * 아래 세가지 요소를 기준으로 해당 사항이 없으면 관계선으로 표현하면 안된다.
  <br/>

  * **관계 도출 시 고려할 사항**
    - 속성으로 관리하려는 관계
    - 참조 무결성 관계
    - 바로 상위의 1차 관계

  * 모든 엔티티는 관계선으로 연결되어 있어야 한다는 원칙도 잘못된 원칙이다. 기준 데이터를 관리하는 엔티티나 집계 엔티티는 다른 엔티티와 어떠한 관계도 존재하지 않을 수도 있다.
  <br/>

##관계 검증
  *   관계는 검증하기 가장 어려운 대상이다 업무 규칙을 아라야 하고 데이터 값을 분석해야 정확한 관계를 파악할 수 있기 때문이다 또한 기계적으로 검토할 수 있는 방법이 거의 없다 대부분 눈으로 관계선 을 확인하면서 검토해야 한다
  <br/>

  * 관계는 존재 여부를 검증하기도 쉽지 않다 엔티티나 속성과 달리 적절한 비교 대상이 없기 때문이다 화면에서 관계 속성이 사용됐는지 대략적으로 검토는 가능하다
  <br/>

  * 관계도 결국 조인을 해야 의미가 있다 따라서 쿼리의 조인 구문을 분석해서 관계선과 매핑하여 검토할 수 있다
  <br/>

  * 관계선이 표현된 엔티티에 대해서는 데이터 사이에 참조 무결성 제약이 있는지를 검토한다
  <br/>

  *  배타 관계는 모델을 복잡하게 만들기 때문에 배타 관계를 발생시킨 엔티티를 통합할 수 있는지를 검토한다
  <br/>

  * 양방향 관계나 순환 관계와 같은 특별한 관계도 검토한다 특히 양방향 관계는 업무 규칙을 제대로 표현한 관계인지를 검토해야 한다
  <br/>

  * 업무 요건을 잘못 반영한 일대일 관계가 있는지를 검토한다
  <br/>

  *  관계가 1 차 관계인지도 검토해야 한다 성능을 고려한 추출 관계를 제외한 모든 관계를 1 차 관계여야 한다
  <br/>

  * 모델이 복잡해져 표현을 생략하기로 약속한 관계선을 제외하고 관계선은 생략하지 않는 것이 원칙이다
  <br/>
